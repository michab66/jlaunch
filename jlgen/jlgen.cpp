/* $Id$
 *
 * Generator cli implementation.
 *
 * Copyright (c) 2019-2020 Michael Binz
 */

// See https://docs.microsoft.com/en-us/windows/uwp/design/globalizing/use-utf8-code-page
#undef UNICODE

#include <cstdio>
#include <fstream>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <filesystem>

#include <smack_cli.hpp>

#include "winicon.h"
#include "ResourceMgr.h"
#include "RtIconGroup.h"
#include "RtStringTable.h"
#include "mod_icons.hpp"
#include "resource.h"
#include "../jlaunch/jlaunch_resource_ids.h"

using std::string;
using std::cerr;
using std::endl;
using std::filesystem::path;
using mob::windows::ResourceMgr;
using mob::windows::RtIconGroup;
using mob::windows::RtIcon;

// Integrate custom type std::filesystem::path for smack::cli.
template<> void smack::convert::transform(const char* in, std::filesystem::path& out) {
    out = in;
}
template<>
const char* smack::convert::get_typename(std::filesystem::path type) {
    return "path";
}

namespace
{
    /**
     * The resource image sizes generated by this tool.
     */
    const std::initializer_list<uint16_t> IMAGE_SIZES =
        { 16, 32, 64, 128, 256 };

    /**
     * Update the icon with the given id in the executable.
     *
     * UpdateIcon C:\Users\Michael\svn\rep_github\jlaunch\x64\Debug\jlaunch.exe ..\mmt-icon-1024.png
     */
    void UpdateIconImpl(
        ResourceMgr& target,
        const path& iconFile)
    {
        std::vector<std::unique_ptr<RtIcon>> outHolder;
        smack::util::icons::CreateIcons(
            outHolder,
            IMAGE_SIZES,
            iconFile);

        RtIconGroup iconGroup;

        for (std::unique_ptr<RtIcon>& a : outHolder)
            iconGroup.Add(a.get());

        target.add(IDI_ICON, iconGroup);
    }

    int WriteLauncher(
        const path& targetFile)
    {
        HMODULE self = GetModuleHandleA(nullptr);

        // Locate the resource in the .EXE file.
        HRSRC hRes = FindResourceA(
            self,
            MAKEINTRESOURCE(IDR_BINARY1),
            RT_RCDATA);
        if (hRes == nullptr)
            throw std::invalid_argument("Could not locate binary resource.");

        // Load the resource.
        HGLOBAL hResLoad = LoadResource(
            self,
            hRes);
        if (hResLoad == nullptr)
            throw std::invalid_argument("Could not load resource.");

        // Lock the resource into global memory.
        void* dir = LockResource(hResLoad);
        if (dir == nullptr)
            throw std::invalid_argument("Could not lock resource.");

        int resourceSize =
            SizeofResource(nullptr, hRes);

        std::ofstream out;
        out.open(targetFile, std::ofstream::binary);
        if (out.fail())
            throw std::invalid_argument("Could not open target file.");

        out.write(
            static_cast<const char*>(dir), resourceSize);
        if (out.fail())
            throw std::invalid_argument("Could not write to target file.");

        out.close();
        if (out.fail())
            throw std::invalid_argument("Could not close target file.");

        return EXIT_SUCCESS;
    }

    /**
     * Default extension of the generated executable.
     */
    const auto exe_k = ".exe";

    /*
     * MakeLauncher C:\cygwin64\tmp\MMT.exe ..\mmt-icon-1024.png  mmt.app de/michab/app/mmt/Mmt
     */
    int MakeLauncher(
        path targetFile,
        const path& iconFile,
        const string& moduleName,
        const string& startClass
    )
    {
        // Ensure we have an .exe extension.
        if (targetFile.extension() != exe_k)
            targetFile.replace_extension(exe_k);

        cerr << "Creating launcher: " << targetFile << endl;
        WriteLauncher(targetFile);

        ResourceMgr target{ targetFile };

        mob::windows::RtString strings;

        // Covert dot-notation to invocation API conventions.
        string actualStartClass{ startClass };
        std::replace(
            actualStartClass.begin(),
            actualStartClass.end(),
            '.',
            '/');

        cerr << "Adding main class name: " << actualStartClass << endl;
        strings.Add(
            IDS_JAVA_MAIN_CLASS,
            actualStartClass);

        cerr << "Adding main module name: " << moduleName << endl;
        strings.Add(
            IDS_JAVA_MAIN_MODULE, 
            moduleName);
        cerr << "Adding info to string table."<< endl;
        target.add(
            IDS_STRINGS,
            strings);

        cerr << "Adding icons from: " << iconFile << endl;
        UpdateIconImpl(target, iconFile);

        cerr << "Committing resource additions." << endl;
        target.commit();

        return EXIT_SUCCESS;
    }

    /**
     * Create an .ico icon file for Windows.  Create target file at position
     * of input file with extension .ico.
     *
     * @param pngFile Input png.
     */
    int CreateWindowsIcon(
        const string& pngFile)
    {
        path icnFile = pngFile;
        icnFile.replace_extension(".ico");

        cerr << "Writing icon file: " << icnFile << endl;

        smack::util::icons::CreateWindowsIcon(
            pngFile,
            IMAGE_SIZES,
            icnFile);

        return EXIT_SUCCESS;
    }

    /**
     * Create an .icns icon for Mac.  Create target file at position
     * of input file with extension .icns.
     *
     * @param pngFile Input png.
     */
    int CreateAppleIcon(
        const string& pngFile)
    {
        path icnFile = pngFile;
        icnFile.replace_extension(".icns");

        cerr << "Writing icon file: " << icnFile << endl;

        // TODO(michab66) The Apple iconviewer expects 16,32,128,256,512.
        // But the file with our current setting seems to work.
        smack::util::icons::CreateAppleIcon(
            pngFile,
            IMAGE_SIZES,
            icnFile);

        return EXIT_SUCCESS;
    }
} // namespace unnamed

// MakeLauncher c:\cygwin64\tmp\xxx.exe C:\cygwin64\tmp\jlaunch\MMT.ico app.mmt de/michab/app/mmt/Mmt
int main(int argc, char** argv) {
    using smack::cli::Commands;

    smack::cli::CliApplication cli(
        "The swiss army knife for Windows Java-launcher generation.",
        Commands::make<WriteLauncher>(
            "WriteLauncher",
            "Write a launcher for test purposes.",
            {
                "targetFilename"
            }),
        Commands::make<MakeLauncher>(
            "MakeLauncher",
            "Create a launcher using the passed parameters.",
            {
                "targetFile",
                "iconFile",
                "moduleName",
                "startClass"
            }),
        Commands::make<CreateWindowsIcon>(
            "CreateWindowsIcon",
            "Create a Windows .icn file from the passed .png.",
            {
                "pngFilename",
            }),
        Commands::make<CreateAppleIcon>(
            "CreateAppleIcon",
            "Create a MacOs .icns file from the passed .png.",
            {
                "pngFilename",
            })
            );

    return cli.launch(argc, argv);
}
